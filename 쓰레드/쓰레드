
쓰레드의 구현과 실행

1. Thread 클래스를 상속 , run()을 오버라이딩 
2. Runnable 인터페이스를 구현 , 추상메서드 run()을 구현 -> run에서 작업내용을 적는다 

1번방법
MyThread t1 = new MyThread();  스레드 생성
t1.start(); 스레드 실행

Runnable r = new MyThread2();  
Thread t2 = new Thread(r); // Thread(Runnable r)

// Thread t2 = new Thread(new MyThread2());  <- 한줄로 처리   Run이라는 메서드의 구현체를 외부에서 매개변수로 받음 Thread메서드를 호출함 
t2.start();  
13-5 쓰레드의 실행 - start()
쓰레드를 생성한 후 에 start() 호출해야 쓰레드가 작업을 시작한다

쓰레드마다 실행순서는 OS 스케줄러가 실행순서결정 

run()을 작성했는데 왜 Start()가 호출할까 ?

1. Call stack 에서 main위에 start 
start 가 새로운 호출스텍을 생성해서 run 을 올린다
start 가 종료되고 나면 
각각의 스레드가 자기만의 호출 스텍을 가지고 실행한다 그래서 서로 독립적인 작업을 할수 있다 

main 쓰레드
main메서드의 코드를 수행하는 쓰레드
쓰레드는 사용자쓰레드 와 데몬쓰레드 두 가지 종류가 있다 
사용자 쓰레드는 main 쓰레드 이고 , 데몬 쓰레드는 보조 쓰레드 역할을 한다 
실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다

쓰레드의 I/O 블락킹(blocking)
Input / Output
입력 과 출력 을 줄어서 입출력 이라고 함  , 블락킹 = 막힘 

싱글스레드 - 사용자로부터 입력을 기다리는 구간 아무일도 하지 않는다
멀티스레드 - 사용자로부터 입력을 기다리는 구간, th2 가 수행된다 

쓰레드의 우선순위 
작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드가 더 많은 작업시간을 갖게 할 수 있다 
public static final int MAX_PRIORITY = 10; // 최대 우선순위
public static final int MAX_PRIORITY = 1; // 최소 우선순위
public static final int MAX_PRIORITY = 5; // 보통 우선순위

void setPriority(int newPriority) // 
int getPriority() // 쓰레드의 우선순위를 반환한다.

우선순위가 높은경우 더 많은 할당을 받는다

쓰레드 그룹
서로 관련된 쓰레드를 그룹으로 묶어서 다루기 위한 것
모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야 한다.
쓰레드 그룹을 지정하지 않고 생성한 쓰레드는 main 쓰레드 그룹에 속한다
자신을 생성한 쓰레드(부모 쓰레드)의 그룹과 우선순위를 상속받는다

데몬스레드
일반 쓰레드의 작업을 돋는 보조적인 역할을 수행 - 일반쓰레드와 데몬쓰레드
일반 쓰레드가 모두 종료되면 자동적으로 종료됨
가비지 컬렉터 , 자동 저장 화면 자동갱신 등에 사용된다 
무한루프와 조건문을 이용해서 실행 후 대기하다가 특정조건이 만족되면 작업을 수행하고 다시 대기 하도록 작성한다


코딩 팩토리
Thread란?
하나의 프로세스 내부에서 독립적으로 실행되는 하나의 작업단위를 말하며 세부적으로는 운영체제에 의해 관리되는 하나의 작업 혹은 태스크를 의미 . 스레드와 태스크(혹은 작업)은 바꾸어 사용해도 무관
1. JVM 에 의해 하나의 프로세스가 발생하고 main() 안의 실행문 들이 하나의 스레드 이다
2. main() 이외의 또 다른 스레드를 만들려면 Thread 클래스를 상속하거나 Runnable 인터페이스를 구현함
3. 다중 스레드 작업 시에는 각 스레드 끼리 정보를 주고 받을 수 있어 처리 과정의 오류를 줄일 수 있다
4. 프로세스끼리는 정보를 주고받을 수 잆다 

멀티스레딩이란?
여러 스레드를 동시에 실행시키는 응용프로그램을 작성하는 기법을 말한다

장점
1.메모리 공유로 인한 시스템 자원 소모가 줄어든다
2.동시에 두가지 이상의 활동을 하는 것이 가능해진다

단점
1. 서로 자원을 소모하다가 충돌이 일어날 가능성이 존재
2. 코딩이 난해해져 버그생성확률이 높아짐

				 준비상태전환 Runnable  대기전환 Blocked 
new -> start() -> Runnable -> Run() 호출 -> Running -> Dead 

Runnable 상태 : 쓰레드가 실행되기 위한 준비 단계
Running 상태 : 스케줄러에 의해 선택된 쓰레드가 실행되는 단계
Blocked 상태 : 쓰레드가 작업을 완수하지 못하고 잠시 작업을 멈추는 단계 

Runnable (준비상태)
Running (실행상태)
Dead (종료상태)
Blocked (지연상태)

동기화 메서드와 동기화(Synchorized) 블록
공유 객체를 사용할 때 주의할 점
멀티스레드 프로그램에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있다
이 경우 스레드 A를 사용하던 객체가 스레드 B에 의해 상태가 변경될 수 있기 때문에 스레드A가 의도했던
것과는 다른 결과를 산출할 수 있다.

스레드 상태 제어
스레드를 일시정지 상태로 만들거나 정지된 스레드를 다시 실행 시키거나 하는 행위
실행 중인 스레드의 상태 변경 하는 것을 스레드 상태 제어 라고 한다

다른 스레드 에게 실행을 양보 한다 -> yield()

join() 다른 스레드의 종료를 기다린다
스레드는 다른 스레드와 독립적으로 실행되는것이 일반적이지만 다른 스레드가 종료될 때 까지 기다리다가 실행되어야 하는 경우가 발생할 수 있다

예를들어 B라는 스레드는 계산을 하는 스레드 이고 , A라는 스레드는 B스레드가 계산이 끝나면 그 결과값을 가지고 로직을 처리해야 하는 상황이다

ThreadA {
	ThreadB.start(); // (실행순서 1)
	ThreadB.join();  // 일시정지
	
	... ThreadA 로직 수행 // (실행순서 3)
}

ThreadB {
	run() {
		// ThreadB 작업 실행(실행순서 2)
	}
}





















